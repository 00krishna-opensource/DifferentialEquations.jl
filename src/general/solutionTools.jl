"""
FEMSolution

Holds the data for the solution to a finite element problem.

### Fields

* `femMesh::FEMmesh`: The finite element mesh the problem was solved on.
* `u::Array{Float64}`: The solution (at the final timepoint)
* `trueKnown::Bool`: Boolean flag for if the true solution is given.
* `uTrue::AbstractArrayOrVoid`: The true solution at the final timepoint.
* `l2Err::NumberOrVoid`: The L2 error between u and uTrue.
* `h1Err::NumberOrVoid`: The H1 error between u and uTrue.
* `maxErr::NumberOrVoid`: The nodal maximum error between u and uTrue.
* `nodeErr2::NumberOrVoid`: The nodal l2 error between y abd uTrue.
* `appxTrue::Bool`: Boolean flag for if uTrue was an approximation.
* `uFull`::AbstractArrayOrVoid`: u over time. Only saved if `fullSave=true`
is specified in the solver.
* `tFull::AbstractArrayOrVoid`: All the t's in the solution. Only saved if `fullSave=true`
is specified in the solver.
* `fullSave::Bool`: True if solver saved the extra timepoints.

"""
type FEMSolution <: PdeSolution
  femMesh::FEMmesh
  u::Array{Float64}
  trueKnown::Bool
  uTrue::AbstractArrayOrVoid
  l2Err::NumberOrVoid
  h1Err::NumberOrVoid
  maxErr::NumberOrVoid
  nodeErr2::NumberOrVoid
  appxTrue::Bool
  uFull::AbstractArrayOrVoid
  tFull::AbstractArrayOrVoid
  fullSave::Bool
  function FEMSolution(femMesh::FEMmesh,u,uTrue,sol,Du,uFull,tFull;fullSave=true)
    l2Err = getL2error(femMesh,sol,u)
    h1Err = getH1error(femMesh,Du,u)
    maxErr = maximum(abs(u-uTrue))
    nodeErr2 = norm(u-uTrue,2)
    return(new(femMesh,u,true,uTrue,l2Err,h1Err,maxErr,nodeErr2,false,uFull,tFull,true))
  end
  FEMSolution(femMesh,u,uTrue,sol,Du) = FEMSolution(femMesh::FEMmesh,u,uTrue,sol,Du,nothing,nothing,fullSave=false)
  function FEMSolution(femMesh::FEMmesh,u::AbstractArray)
    return(FEMSolution(femMesh,u,nothing,nothing,fullSave=true))
  end
  function FEMSolution(femMesh::FEMmesh,u::AbstractArray,uFull,tFull;fullSave=true)
    return(new(femMesh,u,false,nothing,nothing,nothing,nothing,nothing,false,uFull,tFull,fullSave))
  end
end

"""
ConvergenceSimulation

A type which holds the data from a convergence simulation.

### Fields

* `solutions::Array{PdeSolution}`: Holds all the PdeSolutions.
* `h1Errors`: Vector of the H1 errors.
* `l2Errors`: Vector of the L2 errors.
* `maxErrors`: Vector of the nodal maximum errors.
* `node2Errors`: Vector of the nodal l2 errors.
* `N`: The number of simulations.
* `Δts`: The Δt's in the simulations.
* `Δxs`: The Δx's in the simulations.
* `μs`: The CFL μ's in the simulations.
* `νs`: The CFL ν's in the simulations.
* `ConvEst_h1`: The H1 error order of convergence estimate for the convergence simulation.
Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
the Δt/Δx. If alternate scaling, modify by dividing of log(base,ConvEst_h1)
* `ConvEst_l2`: The L2 error order of convergence estimate for the convergence simulation.
Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
the Δt/Δx. If alternate scaling, modify by dividing of log(base,ConvEst_l2)
* `ConvEst_max`: The nodal maximum error order of convergence estimate for the convergence simulation.
Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
the Δt/Δx. If alternate scaling, modify by dividing of log(base,ConvEst_max)
* `ConvEst_node2`: The nodal l2 error order of convergence estimate for the convergence simulation.
Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
the Δt/Δx. If alternate scaling, modify by dividing of log(base,ConvEst_node2)

"""
type ConvergenceSimulation
  solutions::Array{PdeSolution}
  h1Errors
  l2Errors
  maxErrors
  node2Errors
  N
  Δts
  Δxs
  μs
  νs
  ConvEst_h1
  ConvEst_l2
  ConvEst_max
  ConvEst_node2
  function ConvergenceSimulation(solutions::Array{PdeSolution})
    N = length(solutions)
    Δts = Vector{Float64}(N)
    Δxs = Vector{Float64}(N)
    μs = Vector{Float64}(N)
    νs = Vector{Float64}(N)
    for i = 1:N
      Δts[i] = solutions[i].femMesh.Δt
      Δxs[i] = solutions[i].femMesh.Δx
      μs[i] = solutions[i].femMesh.μ
      νs[i] = solutions[i].femMesh.ν
    end
    if solutions[1].trueKnown
      h1errors = Vector{Float64}(N)
      l2errors = Vector{Float64}(N)
      maxErrs  = Vector{Float64}(N)
      nodeErr2s = Vector{Float64}(N)
      for i = 1:N
        h1errors[i] = solutions[i].h1Err
        l2errors[i] = solutions[i].l2Err
        maxErrs[i]  = solutions[i].maxErr
        nodeErr2s[i] = solutions[i].nodeErr2
      end
      h1Est    = conv_ests(h1errors)
      l2Est    = conv_ests(l2errors)
      maxEst   = conv_ests(maxErrs)
      node2Est = conv_ests(nodeErr2s)
      return(new(solutions,h1errors,l2errors,maxErrs,nodeErr2s,N,Δts,Δxs,μs,
                 νs,h1Est,l2Est,maxEst,node2Est))
    else # No known solution
      if solutions[1].appxTrue # But appx true solution known
        maxErrs  = Vector{Float64}(N)
        nodeErr2s = Vector{Float64}(N)
        for i = 1:N
          maxErrs[i]  = solutions[i].maxErr
          nodeErr2s[i] = solutions[i].nodeErr2
        end
        maxEst   = conv_ests(maxErrs)
        node2Est = conv_ests(nodeErr2s)
        return(new(solutions,nothing,nothing,maxErrs,nodeErr2s,N,Δts,Δxs,μs,νs,nothing,nothing,maxEst,node2Est))
      else #Nothing true known
        return(new(solutions,nothing,nothing,nothing,nothing,N,Δts,Δxs,μs,νs))
      end
    end
  end
  ConvergenceSimulation(solutions::AbstractArray) = ConvergenceSimulation(convert(Array{PdeSolution},solutions)) # To allow robustness with cell
end

"""
length(simres::ConvergenceSimulation)

Returns the number of simultations in the Convergence Simulation
"""
Base.length(simres::ConvergenceSimulation) = simres.N

"""
conv_ests(error::Vector{Number})

Computes the pairwise convergence estimate for a convergence test done by
halving/doubling stepsizes via

log2(error[i+1]/error[i])

Returns the mean of the convergence estimates
"""
function conv_ests(error::Vector{Float64})
  S = Vector{Float64}(length(error)-1)
  for i=1:length(error)-1
    S[i] = log2(error[i+1]/error[i])
  end
  return(abs(mean(S)))
end

"""
appxTrue!(res,res2)

Adds the solution from res2 to the FEMSolution object res.
Useful to add a quasi-true solution when none is known by
computing once at a very small time/space step and taking
that solution as the "true" solution
"""
function appxTrue!(res::PdeSolution,res2::PdeSolution)
  res.uTrue = res2.u
  res.maxErr = maximum(abs(res.u-res.uTrue))
  res.nodeErr2 = norm(res.u-res.uTrue,2)
  res.appxTrue = true
end
