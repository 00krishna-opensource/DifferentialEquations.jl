"""
ConvergenceSimulation

A type which holds the data from a convergence simulation.

### Fields

* `solutions::Array{DESolution}`: Holds all the PdeSolutions.
* `h1Errors`: Vector of the H1 errors.
* `l2Errors`: Vector of the L2 errors.
* `maxErrors`: Vector of the nodal maximum errors.
* `node2Errors`: Vector of the nodal l2 errors.
* `N`: The number of simulations.
* `Δts`: The Δt's in the simulations.
* `Δxs`: The Δx's in the simulations.
* `μs`: The CFL μ's in the simulations.
* `νs`: The CFL ν's in the simulations.
* `ConvEst_h1`: The H1 error order of convergence estimate for the convergence simulation.
Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
the Δt/Δx. If alternate scaling, modify by dividing of log(base,ConvEst_h1)
* `ConvEst_l2`: The L2 error order of convergence estimate for the convergence simulation.
Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
the Δt/Δx. If alternate scaling, modify by dividing of log(base,ConvEst_l2)
* `ConvEst_max`: The nodal maximum error order of convergence estimate for the convergence simulation.
Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
the Δt/Δx. If alternate scaling, modify by dividing of log(base,ConvEst_max)
* `ConvEst_node2`: The nodal l2 error order of convergence estimate for the convergence simulation.
Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
the Δt/Δx. If alternate scaling, modify by dividing of log(base,ConvEst_node2)

"""
type ConvergenceSimulation
  solutions::Array{DESolution}
  errors
  N
  auxData
  𝒪est
  convergenceAxis
  function ConvergenceSimulation(solutions::Array{DESolution},convergenceAxis;auxData=nothing)
    N = size(solutions,1)
    errors = Dict() #Should add type information
    for k in keys(solutions[1].errors)
      errors[k] = reshape(Float64[sol.errors[k] for sol in solutions],size(solutions)...)
    end
    𝒪est = Dict(map(calc𝒪estimates,errors))
    for (k,v) in 𝒪est
      if length(v)==1 𝒪est[k]=v[1] end
    end
    return(new(solutions,errors,N,auxData,𝒪est,convergenceAxis))
  end
end
function ConvergenceSimulation(solutions::Array{SDESolution},convergenceAxis;auxData=nothing)
  ConvergenceSimulation(convert(Array{DESolution},solutions),convergenceAxis;auxData=auxData)
end

function testConvergence(Δts::AbstractArray,prob::SDEProblem;T=1,numMonte=10000,fullSave=true,alg="EM")
  N = length(Δts)
  #solutions = DESolution[solve(prob::SDEProblem,Δts[i],T,fullSave=fullSave,alg=alg) for j=1:numMonte,i=1:N]
  is = repmat(1:N,1,numMonte)'
  solutions = pmap((i)->solve(prob,Δts[i],T,fullSave=fullSave,alg=alg),is)
  solutions = convert(Array{SDESolution},solutions)
  solutions = reshape(solutions,numMonte,N)
  auxData = Dict("Δts" =>  Δts)
  ConvergenceSimulation(solutions,Δts,auxData=auxData)
end

function testConvergence(Δts::AbstractArray,Δxs::AbstractArray,prob::HeatProblem,convergenceAxis;T=1,alg="Euler")
  if length(Δts)!=length(Δxs) error("Lengths of Δts!=Δxs. Invalid convergence simulation") end
  solutions = DESolution[solve(parabolic_squaremesh([0 1 0 1],Δxs[i],Δts[i],T,"Dirichlet"),prob,alg=alg) for i in eachindex(Δts)]
  auxData = Dict(
            "Δts" => [sol.femMesh.Δt for sol in solutions],
            "Δxs" => [sol.femMesh.Δx for sol in solutions],
            "Δμs" => [sol.femMesh.μ  for sol in solutions],
            "Δνs" => [sol.femMesh.ν  for sol in solutions])
  return(ConvergenceSimulation(solutions,convergenceAxis,auxData=auxData))
end

function testConvergence(Δxs::AbstractArray,prob::PoissonProblem;alg="Euler")
  solutions = DESolution[solve(notime_squaremesh([0 1 0 1],Δxs[i],"Dirichlet"),prob) for i in eachindex(Δxs)]
  auxData = Dict("Δxs" => [sol.femMesh.Δx for sol in solutions])
  return(ConvergenceSimulation(solutions,Δxs,auxData=auxData))
end

"""
length(simres::ConvergenceSimulation)

Returns the number of simultations in the Convergence Simulation
"""
Base.length(simres::ConvergenceSimulation) = simres.N

"""
conv_ests(error::Vector{Number})

Computes the pairwise convergence estimate for a convergence test done by
halving/doubling stepsizes via

log2(error[i+1]/error[i])

Returns the mean of the convergence estimates
"""
function calc𝒪estimates(error::Pair)
  key = error.first
  error =error.second
  if ndims(error)>1 error=mean(error,1) end
  S = Vector{Float64}(length(error)-1)
  for i=1:length(error)-1
    S[i] = log2(error[i+1]/error[i])
  end
  return(Pair(key,abs(mean(S,1))))
end

"""
conv_ests(error::AbstractArray{Number})

Computes the pairwise convergence estimate for a convergence test done by
halving/doubling stepsizes via

log2(error[i+1]/error[i])

Returns the mean of the convergence estimates
"""
function conv_ests(error::AbstractArray{Float64})
  S = Vector{Float64}(size(error,1)-1,size(error,2))
  for i=1:size(error,1)-1,j=1:size(error,2)
    S[i,j] = log2(error[i+1,j]/error[i,j])
  end
  return(abs(mean(S)))
end
