using DifferentialEquations, Stats, Distributions, HypothesisTests
prob = linearSDEExample()
srand(200)
T = 2
N = 100
M=10
ps = Vector{Float64}(M)
for j = 1:M
  Wends = Vector{Float64}(N)
  for i = 1:N
    sol =solve(prob::SDEProblem,[0,T],Î”t=1//2^(4),fullSave=true,alg="SRI",adaptive=true,abstol=1e-2,reltol=0)
    Wends[i] = sol.WFull[end]
  end

  kssol = ApproximateOneSampleKSTest(Wends/sqrt(T), Normal())
  ps[j] = pvalue(kssol) #Should be not significant (most of the time)
end
#println(ApproximateOneSampleKSTest(randn(N), Normal()))

#=
#Gadfly QQ-plot
using Gadfly
import Gadfly.ElementOrFunction
# First add a method to the basic Gadfly.plot function for QQPair types (generated by Distributions.qqbuild())
Gadfly.plot(qq::QQPair, elements::ElementOrFunction...) = Gadfly.plot(x=qq.qx, y=qq.qy, Geom.point, Theme(highlight_width=0px), elements...)

qqplot(x, y, elements::ElementOrFunction...) = Gadfly.plot(qqbuild(x, y), elements...)
qqnorm(x, elements::ElementOrFunction...) = qqplot(Normal(), x, Guide.xlabel("Theoretical Normal quantiles"), Guide.ylabel("Observed quantiles"), elements...)
qqplot(Wends/sqrt(T),randn(N))
=#

sum(ps .> 0.05) > length(ps)/2
